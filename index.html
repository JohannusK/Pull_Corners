<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pull Corners (No OpenCV) + PDF</title>
  <style>
    :root { --gap: 10px; }
    html, body { height: 100%; }
    body { margin: 0; font-family: system-ui, sans-serif; background: #111; color: #eee; }
    .app { height: 100%; display: flex; flex-direction: column; min-height: 0; }

    header {
      padding: 10px 14px;
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      border-bottom: 1px solid #222; background: #0f0f0f;
    }
    .pill { padding: 6px 10px; border: 1px solid #333; border-radius: 999px; background: #1a1a1a; }
    button {
      padding: 7px 10px; border-radius: 8px; border: 1px solid #333;
      background: #222; color: #eee; cursor: pointer;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .row { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; }
    .hint { font-size: 12px; opacity: 0.9; line-height: 1.35; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; padding: 2px 6px; border: 1px solid #333; border-radius: 6px; background:#161616; }

    main {
      flex: 1; min-height: 0;
      display: grid; grid-template-columns: 1fr 1.7fr; gap: var(--gap);
      padding: var(--gap); box-sizing: border-box; overflow: hidden;
    }
    .panel {
      background: #0c0c0c; border: 1px solid #2a2a2a; border-radius: 12px;
      overflow: hidden; display:flex; flex-direction:column; min-height:0;
    }
    .panel h3 { margin:0; padding: 10px 12px; font-size: 14px; border-bottom: 1px solid #222; background: #141414; }
    .canvasWrap { position: relative; flex:1; min-height:0; }
    canvas { width: 100%; height: 100%; display:block; }

    /* Modal */
    .modalBackdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,0.7);
      display: none; align-items: center; justify-content: center;
      padding: 18px; box-sizing: border-box;
    }
    .modal {
      background: #101010; border: 1px solid #333; border-radius: 12px;
      width: min(1100px, 95vw); height: min(92vh, 920px);
      display:flex; flex-direction:column; min-height:0;
    }
    .modal header { padding: 10px 12px; border-bottom: 1px solid #222; }
    .modal .content { flex:1; min-height:0; padding: 10px; display:flex; align-items:center; justify-content:center; }
    /* IMPORTANT: do NOT force the preview canvas to stretch */
    .modal canvas { background:#000; border-radius: 10px; width:auto; height:auto; max-width:100%; max-height:100%; }
  </style>
</head>

<body>
<div class="app">
  <header>
    <button id="openBtn">Open images</button>
    <input id="fileInput" type="file" accept="image/*" multiple hidden />

    <button id="pdfBtn" disabled>Download PDF (all)</button>

    <span class="pill">Orientation:</span>
    <button id="portraitBtn">Portrait</button>
    <button id="landscapeBtn">Landscape</button>

    <span class="pill">File: <b id="imgName">—</b></span>
    <span class="pill">Active: <b id="activePt">1</b></span>
    <span class="pill">Zoom: <b id="zoomVal">6.0×</b></span>

    <span class="pill" id="status">Ready. Open images.</span>

    <div class="hint">
      Keys: <span class="kbd">1-4</span> select • Arrows move (step scales with zoom) •
      <span class="kbd">+</span>/<span class="kbd">-</span> zoom •
      <span class="kbd">Enter</span> preview • <span class="kbd">Enter</span> download JPG •
      <span class="kbd">Esc</span> close preview • <span class="kbd">n</span>/<span class="kbd">b</span> next/back
    </div>
  </header>

  <main>
    <section class="panel">
      <h3>Full image</h3>
      <div class="canvasWrap"><canvas id="fullCanvas"></canvas></div>
    </section>

    <section class="panel">
      <h3>Zoomed active point</h3>
      <div class="canvasWrap"><canvas id="zoomCanvas"></canvas></div>
    </section>
  </main>

  <div class="modalBackdrop" id="modalBackdrop" tabindex="-1">
    <div class="modal">
      <header>
        <div class="row">
          <span class="pill">Preview</span>
          <span class="pill">Enter = download JPG • Esc = close</span>
          <span class="pill">Output: <b id="outName">—</b></span>
          <span class="pill" id="workPill" style="display:none;">Working…</span>
        </div>
      </header>
      <div class="content">
        <canvas id="previewCanvas"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- PDF generation (Level A) -->
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

<script>
  // ---------- Output sizes ----------
  const A4_PORTRAIT = [2480, 3508];
  const A4_LANDSCAPE = [3508, 2480];
  let OUT_W = A4_PORTRAIT[0], OUT_H = A4_PORTRAIT[1];

  // Preview max width (in pixels) to keep it responsive
  const PREVIEW_MAX_W = 1300;

  // ---------- UI ----------
  const statusEl = document.getElementById("status");
  const imgNameEl = document.getElementById("imgName");
  const activePtEl = document.getElementById("activePt");
  const zoomValEl = document.getElementById("zoomVal");
  const outNameEl = document.getElementById("outName");
  const workPill = document.getElementById("workPill");

  const openBtn = document.getElementById("openBtn");
  const fileInput = document.getElementById("fileInput");
  const pdfBtn = document.getElementById("pdfBtn");

  const portraitBtn = document.getElementById("portraitBtn");
  const landscapeBtn = document.getElementById("landscapeBtn");

  const fullCanvas = document.getElementById("fullCanvas");
  const zoomCanvas = document.getElementById("zoomCanvas");
  const previewCanvas = document.getElementById("previewCanvas");

  const modalBackdrop = document.getElementById("modalBackdrop");

  const fullCtx = fullCanvas.getContext("2d");
  const zoomCtx = zoomCanvas.getContext("2d");

  // ---------- State ----------
  let files = [];
  let fileUrls = [];
  let current = -1;
  let img = new Image();
  let imgLoaded = false;

  // points in image coords TL, TR, BR, BL
  let pts = null;
  let active = 0;
  let zoom = 6.0;

  let dragging = false;

  // mapping from full canvas to image coords
  let fullScale = 1.0, fullOffsetX = 0, fullOffsetY = 0, fullDrawW = 0, fullDrawH = 0;

  function setStatus(t) { statusEl.textContent = t; }
  function dpr() { return Math.max(1, window.devicePixelRatio || 1); }

  function resizeCanvasToCSS(canvas) {
    const r = canvas.getBoundingClientRect();
    const s = dpr();
    const w = Math.max(1, Math.floor(r.width * s));
    const h = Math.max(1, Math.floor(r.height * s));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
  }

  function resetDefaultPoints() {
    const w = img.naturalWidth, h = img.naturalHeight;
    pts = [
      [Math.round(w*0.1), Math.round(h*0.1)],
      [Math.round(w*0.9), Math.round(h*0.1)],
      [Math.round(w*0.9), Math.round(h*0.9)],
      [Math.round(w*0.1), Math.round(h*0.9)],
    ];
    active = 0;
  }

  function clampPoint(i) {
    const w = img.naturalWidth, h = img.naturalHeight;
    pts[i][0] = Math.max(0, Math.min(w-1, pts[i][0]));
    pts[i][1] = Math.max(0, Math.min(h-1, pts[i][1]));
  }

  function stepForZoom() {
    return Math.max(1, Math.round(8 / zoom));
  }

  function draw() {
    if (!imgLoaded) return;

    resizeCanvasToCSS(fullCanvas);
    resizeCanvasToCSS(zoomCanvas);

    const iw = img.naturalWidth, ih = img.naturalHeight;

    // Fit entire image in the full panel
    fullCtx.setTransform(1,0,0,1,0,0);
    fullCtx.clearRect(0,0,fullCanvas.width, fullCanvas.height);

    fullScale = Math.min(fullCanvas.width / iw, fullCanvas.height / ih);
    fullDrawW = Math.floor(iw * fullScale);
    fullDrawH = Math.floor(ih * fullScale);
    fullOffsetX = Math.floor((fullCanvas.width - fullDrawW)/2);
    fullOffsetY = Math.floor((fullCanvas.height - fullDrawH)/2);

    fullCtx.drawImage(img, 0,0,iw,ih, fullOffsetX, fullOffsetY, fullDrawW, fullDrawH);

    // polygon
    const p = pts.map(([x,y]) => [fullOffsetX + x*fullScale, fullOffsetY + y*fullScale]);
    fullCtx.strokeStyle = "#00ff6a";
    fullCtx.lineWidth = 2 * dpr();
    fullCtx.beginPath();
    fullCtx.moveTo(p[0][0], p[0][1]);
    for (let i=1;i<4;i++) fullCtx.lineTo(p[i][0], p[i][1]);
    fullCtx.closePath();
    fullCtx.stroke();

    // points
    for (let i=0;i<4;i++) {
      const [px, py] = p[i];
      fullCtx.fillStyle = (i===active) ? "#ff3b3b" : "#00ff6a";
      fullCtx.beginPath();
      fullCtx.arc(px, py, 7*dpr(), 0, Math.PI*2);
      fullCtx.fill();
      fullCtx.font = `${14*dpr()}px system-ui`;
      fullCtx.fillText(String(i+1), px + 10*dpr(), py + 5*dpr());
    }

    // zoom panel
    zoomCtx.setTransform(1,0,0,1,0,0);
    zoomCtx.clearRect(0,0,zoomCanvas.width, zoomCanvas.height);

    const [ax, ay] = pts[active];
    const base = 180;
    const half = Math.max(12, Math.floor(base / zoom));

    const x1 = Math.max(0, ax - half);
    const y1 = Math.max(0, ay - half);
    const x2 = Math.min(iw, ax + half);
    const y2 = Math.min(ih, ay + half);

    const cropW = x2 - x1;
    const cropH = y2 - y1;

    const s2 = Math.min(zoomCanvas.width / cropW, zoomCanvas.height / cropH);
    const dw = Math.floor(cropW * s2);
    const dh = Math.floor(cropH * s2);
    const zx = Math.floor((zoomCanvas.width - dw)/2);
    const zy = Math.floor((zoomCanvas.height - dh)/2);

    zoomCtx.drawImage(img, x1,y1,cropW,cropH, zx,zy,dw,dh);

    // crosshair
    const cx = zx + (ax - x1) * s2;
    const cy = zy + (ay - y1) * s2;
    zoomCtx.strokeStyle = "#ff3b3b";
    zoomCtx.lineWidth = 2 * dpr();
    zoomCtx.beginPath();
    zoomCtx.moveTo(cx-20*dpr(), cy); zoomCtx.lineTo(cx+20*dpr(), cy);
    zoomCtx.moveTo(cx, cy-20*dpr()); zoomCtx.lineTo(cx, cy+20*dpr());
    zoomCtx.stroke();

    imgNameEl.textContent = files[current]?.name ?? "—";
    activePtEl.textContent = String(active+1);
    zoomValEl.textContent = `${zoom.toFixed(1)}×`;
  }

  function fullCanvasToImage(e) {
    const rect = fullCanvas.getBoundingClientRect();
    const s = dpr();
    const mx = (e.clientX - rect.left) * s;
    const my = (e.clientY - rect.top) * s;

    const x = (mx - fullOffsetX) / fullScale;
    const y = (my - fullOffsetY) / fullScale;
    return [x, y];
  }

  function dist2(a,b){ const dx=a[0]-b[0], dy=a[1]-b[1]; return dx*dx+dy*dy; }
  function pickNearestPoint(x,y) {
    const maxPx = 35;
    let best=-1, bestD=1e18;
    for (let i=0;i<4;i++) {
      const d = dist2([x,y], pts[i]);
      if (d < bestD) { bestD = d; best = i; }
    }
    if (Math.sqrt(bestD) <= maxPx) return best;
    return -1;
  }

  fullCanvas.addEventListener("mousedown", (e) => {
    if (!imgLoaded) return;
    const [x,y] = fullCanvasToImage(e);
    const i = pickNearestPoint(x,y);
    if (i !== -1) {
      active = i;
      dragging = true;
      draw();
    }
  });
  window.addEventListener("mouseup", () => { dragging = false; });
  fullCanvas.addEventListener("mousemove", (e) => {
    if (!imgLoaded || !dragging) return;
    const [x,y] = fullCanvasToImage(e);
    pts[active][0] = Math.round(x);
    pts[active][1] = Math.round(y);
    clampPoint(active);
    draw();
  });

  // ------------------ Pure-JS perspective warp (same approach as your working version) ------------------

  function computeHomography(srcPts, dstPts) {
    const A = [];
    const b = [];
    for (let i=0;i<4;i++) {
      const [x,y] = srcPts[i];
      const [u,v] = dstPts[i];
      A.push([x, y, 1, 0, 0, 0, -u*x, -u*y]); b.push(u);
      A.push([0, 0, 0, x, y, 1, -v*x, -v*y]); b.push(v);
    }
    const x = solveLinearSystem(A, b);
    return [
      [x[0], x[1], x[2]],
      [x[3], x[4], x[5]],
      [x[6], x[7], 1   ],
    ];
  }

  function solveLinearSystem(A, b) {
    const n = b.length;
    const M = A.map((row,i) => row.concat([b[i]]));
    for (let col=0; col<n; col++) {
      let pivot = col;
      for (let r=col+1; r<n; r++) {
        if (Math.abs(M[r][col]) > Math.abs(M[pivot][col])) pivot = r;
      }
      if (Math.abs(M[pivot][col]) < 1e-12) throw new Error("Singular system");
      [M[col], M[pivot]] = [M[pivot], M[col]];

      const div = M[col][col];
      for (let c=col; c<=n; c++) M[col][c] /= div;

      for (let r=0; r<n; r++) {
        if (r === col) continue;
        const factor = M[r][col];
        for (let c=col; c<=n; c++) M[r][c] -= factor * M[col][c];
      }
    }
    return M.map(row => row[n]);
  }

  function invert3x3(H) {
    const a=H[0][0], b=H[0][1], c=H[0][2];
    const d=H[1][0], e=H[1][1], f=H[1][2];
    const g=H[2][0], h=H[2][1], i=H[2][2];

    const A =   e*i - f*h;
    const B = -(d*i - f*g);
    const C =   d*h - e*g;
    const D = -(b*i - c*h);
    const E =   a*i - c*g;
    const F = -(a*h - b*g);
    const G =   b*f - c*e;
    const Hh= -(a*f - c*d);
    const I =   a*e - b*d;

    const det = a*A + b*B + c*C;
    if (Math.abs(det) < 1e-12) throw new Error("Non-invertible homography");
    const invDet = 1/det;

    return [
      [A*invDet, D*invDet, G*invDet],
      [B*invDet, E*invDet, Hh*invDet],
      [C*invDet, F*invDet, I*invDet],
    ];
  }

  function applyHomography(H, x, y) {
    const X = H[0][0]*x + H[0][1]*y + H[0][2];
    const Y = H[1][0]*x + H[1][1]*y + H[1][2];
    const W = H[2][0]*x + H[2][1]*y + H[2][2];
    return [X/W, Y/W];
  }

  function getPixelBilinear(src, sw, sh, x, y) {
    if (x < 0) x = 0;
    if (y < 0) y = 0;
    if (x > sw-1) x = sw-1;
    if (y > sh-1) y = sh-1;

    const x0 = Math.floor(x), y0 = Math.floor(y);
    const x1 = Math.min(sw-1, x0+1);
    const y1 = Math.min(sh-1, y0+1);
    const dx = x - x0, dy = y - y0;

    const i00 = (y0*sw + x0)*4;
    const i10 = (y0*sw + x1)*4;
    const i01 = (y1*sw + x0)*4;
    const i11 = (y1*sw + x1)*4;

    const out = [0,0,0,255];
    for (let c=0;c<3;c++) {
      const p00 = src[i00+c], p10 = src[i10+c], p01 = src[i01+c], p11 = src[i11+c];
      const p0 = p00*(1-dx) + p10*dx;
      const p1 = p01*(1-dx) + p11*dx;
      out[c] = p0*(1-dy) + p1*dy;
    }
    return out;
  }

  function warpToCanvas(outputW, outputH, targetCanvas) {
    // Source pixels
    const srcCanvas = document.createElement("canvas");
    srcCanvas.width = img.naturalWidth;
    srcCanvas.height = img.naturalHeight;
    const sctx = srcCanvas.getContext("2d", { willReadFrequently: true });
    sctx.drawImage(img, 0, 0);
    const sw = srcCanvas.width, sh = srcCanvas.height;
    const srcData = sctx.getImageData(0,0,sw,sh).data;

    // Homography src -> dst rect
    const dstPts = [
      [0,0],
      [outputW-1, 0],
      [outputW-1, outputH-1],
      [0, outputH-1]
    ];
    const H = computeHomography(pts, dstPts);
    const Hinv = invert3x3(H);

    targetCanvas.width = outputW;
    targetCanvas.height = outputH;
    const tctx = targetCanvas.getContext("2d", { willReadFrequently: true });
    const outImg = tctx.createImageData(outputW, outputH);
    const out = outImg.data;

    let k = 0;
    for (let y=0; y<outputH; y++) {
      for (let x=0; x<outputW; x++, k+=4) {
        const [sx, sy] = applyHomography(Hinv, x, y);
        const [r,g,b,a] = getPixelBilinear(srcData, sw, sh, sx, sy);
        out[k]   = r;
        out[k+1] = g;
        out[k+2] = b;
        out[k+3] = a;
      }
    }
    tctx.putImageData(outImg, 0, 0);
  }

  // ------------------ Preview + download ------------------

  function fitA4InContainer(containerW, containerH) {
    const ratio = OUT_H / OUT_W;
    let w = Math.min(containerW, PREVIEW_MAX_W);
    let h = w * ratio;
    if (h > containerH) {
      h = containerH;
      w = h / ratio;
    }
    return [Math.floor(w), Math.floor(h)];
  }

  function openPreview() {
    if (!imgLoaded) return;

    const outName = (files[current]?.name ?? "image").replace(/\.[^.]+$/, "") + "_flat.jpg";
    outNameEl.textContent = outName;

    modalBackdrop.style.display = "flex";
    workPill.style.display = "inline-flex";
    workPill.textContent = "Working…";

    // Let modal render before heavy work
    setTimeout(() => {
      try {
        const content = previewCanvas.parentElement.getBoundingClientRect();
        const [pw, ph] = fitA4InContainer(content.width, content.height);
        warpToCanvas(pw, ph, previewCanvas);
        workPill.style.display = "none";
        // Focus so Enter/Esc works reliably
        modalBackdrop.focus();
      } catch (e) {
        workPill.textContent = "Error";
        setStatus("Preview failed: " + e.message);
      }
    }, 30);
  }

  function closePreview() {
    modalBackdrop.style.display = "none";
  }

  function downloadCurrentFlatJpg() {
    const outName = (files[current]?.name ?? "image").replace(/\.[^.]+$/, "") + "_flat.jpg";

    workPill.style.display = "inline-flex";
    workPill.textContent = "Rendering full-res…";

    setTimeout(() => {
      try {
        const off = document.createElement("canvas");
        warpToCanvas(OUT_W, OUT_H, off);
        off.toBlob((blob) => {
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = outName;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(a.href), 1000);
          workPill.style.display = "none";
          closePreview();
        }, "image/jpeg", 0.95);
      } catch (e) {
        workPill.textContent = "Error";
        setStatus("Download failed: " + e.message);
      }
    }, 30);
  }

  // ------------------ PDF export (Level A) ------------------

  async function downloadPdfAll() {
    if (!files.length) return;

    setStatus("Building PDF… (this can take a bit)");
    pdfBtn.disabled = true;

    try {
      const { PDFDocument } = PDFLib;
      const pdf = await PDFDocument.create();

      const off = document.createElement("canvas");

      for (let i=0; i<files.length; i++) {
        current = i;
        await loadCurrent(); // loads image + resets points (you can adjust per page before PDF export if you want)
        // NOTE: If you want it to use your edited points for each page, we need to store points per page.
        // For now, PDF export uses the CURRENT points of the currently loaded image at export time.
        // Best workflow: flatten each page by downloading JPGs, then use your existing desktop img2pdf + ocrmypdf.

        warpToCanvas(OUT_W, OUT_H, off);

        const jpgBytes = await new Promise((resolve) => {
          off.toBlob(async (b) => resolve(await b.arrayBuffer()), "image/jpeg", 0.95);
        });

        const jpg = await pdf.embedJpg(jpgBytes);
        const page = pdf.addPage([OUT_W, OUT_H]);
        page.drawImage(jpg, { x: 0, y: 0, width: OUT_W, height: OUT_H });

        setStatus(`Building PDF… ${i+1}/${files.length}`);
      }

      const pdfBytes = await pdf.save();
      const blob = new Blob([pdfBytes], { type: "application/pdf" });

      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "report.pdf";
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1000);

      setStatus("PDF ready.");
    } catch (e) {
      setStatus("PDF failed: " + e.message);
    } finally {
      pdfBtn.disabled = false;
    }
  }

  // IMPORTANT NOTE ABOUT PDF:
  // To export a correct PDF of your manually adjusted corners per page,
  // the app must remember points per file. If you want that, I’ll add it (localStorage or in-memory).
  // Right now the PDF export uses the *current* points after loadCurrent() resets defaults.

  // ------------------ Keyboard ------------------

  window.addEventListener("keydown", (e) => {
    if (!imgLoaded) return;

    const modalOpen = (modalBackdrop.style.display === "flex");
    if (modalOpen) {
      if (e.key === "Escape") { closePreview(); e.preventDefault(); return; }
      if (e.key === "Enter")  { downloadCurrentFlatJpg(); e.preventDefault(); return; }
      return;
    }

    if (["1","2","3","4"].includes(e.key)) {
      active = Number(e.key) - 1;
      draw();
      e.preventDefault();
      return;
    }

    if (e.key === "+" || e.key === "=") {
      zoom = Math.min(50, zoom * 1.25);
      draw();
      e.preventDefault();
      return;
    }
    if (e.key === "-" || e.key === "_") {
      zoom = Math.max(1.5, zoom / 1.25);
      draw();
      e.preventDefault();
      return;
    }

    if (e.key === "Enter") {
      openPreview();
      e.preventDefault();
      return;
    }

    if (e.key === "n") { if (current < files.length-1) { current++; loadCurrent(); } e.preventDefault(); return; }
    if (e.key === "b") { if (current > 0) { current--; loadCurrent(); } e.preventDefault(); return; }

    const step = stepForZoom();
    if (e.key === "ArrowLeft")  { pts[active][0] -= step; clampPoint(active); draw(); e.preventDefault(); return; }
    if (e.key === "ArrowRight") { pts[active][0] += step; clampPoint(active); draw(); e.preventDefault(); return; }
    if (e.key === "ArrowUp")    { pts[active][1] -= step; clampPoint(active); draw(); e.preventDefault(); return; }
    if (e.key === "ArrowDown")  { pts[active][1] += step; clampPoint(active); draw(); e.preventDefault(); return; }
  });

  // ------------------ File loading ------------------

  openBtn.onclick = () => fileInput.click();

  fileInput.onchange = async () => {
    if (!fileInput.files?.length) return;

    // Clean old URLs
    for (const u of fileUrls) URL.revokeObjectURL(u);

    files = Array.from(fileInput.files);
    files.sort((a,b) => a.name.localeCompare(b.name, undefined, { numeric:true, sensitivity:"base" }));

    fileUrls = files.map(f => URL.createObjectURL(f));
    current = 0;

    await loadCurrent();
    pdfBtn.disabled = false;
  };

  async function loadCurrent() {
    if (current < 0 || current >= fileUrls.length) return;

    setStatus("Loading image…");
    imgLoaded = false;

    await new Promise((resolve) => {
      img.onload = () => resolve();
      img.onerror = () => resolve();
      img.src = fileUrls[current];
    });

    if (!img.naturalWidth) {
      setStatus("Failed to load image.");
      return;
    }

    resetDefaultPoints();
    imgLoaded = true;
    setStatus("Ready.");
    draw();
  }

  // ------------------ Orientation buttons ------------------

  portraitBtn.onclick = () => {
    [OUT_W, OUT_H] = A4_PORTRAIT;
    setStatus("Orientation: Portrait");
  };
  landscapeBtn.onclick = () => {
    [OUT_W, OUT_H] = A4_LANDSCAPE;
    setStatus("Orientation: Landscape");
  };

  // Modal click outside closes
  modalBackdrop.addEventListener("click", (e) => {
    if (e.target === modalBackdrop) closePreview();
  });

  window.addEventListener("resize", () => draw());

  // PDF button
  pdfBtn.onclick = downloadPdfAll;
</script>
</body>
</html>
