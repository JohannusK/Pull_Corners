<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pull Corners</title>
  <style>
    :root { --gap: 10px; --border:#2a2a2a; --bg:#0f0f0f; --panel:#0c0c0c; }
    html, body { height: 100%; }
    body { margin: 0; font-family: system-ui, sans-serif; background: #111; color: #eee; }

    .app { height: 100%; display:flex; flex-direction:column; min-height:0; }
    header{
      padding: 10px 12px;
      display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      border-bottom:1px solid #222; background:var(--bg);
    }
    .group{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .spacer{ flex: 1 1 auto; }
    button, select{
      padding:7px 10px; border-radius:10px; border:1px solid #333;
      background:#1f1f1f; color:#eee; cursor:pointer;
    }
    button:disabled{ opacity:0.45; cursor:not-allowed; }
    select{ background:#1a1a1a; }

    .meta{ font-size:12px; opacity:0.85; }
    .meta b{ opacity:1; }
    .keys{ font-size:12px; opacity:0.75; }
    .kbd{ font-family:ui-monospace, SFMono-Regular, Menlo, monospace; padding:2px 6px; border:1px solid #333; border-radius:6px; background:#161616; }

    main{
      flex:1; min-height:0;
      display:grid; grid-template-columns:1fr 1.7fr; gap:var(--gap);
      padding:var(--gap); box-sizing:border-box;
    }
    .panel{
      background:var(--panel); border:1px solid var(--border); border-radius:14px;
      overflow:hidden; display:flex; flex-direction:column; min-height:0;
    }
    .panel h3{
      margin:0; padding:10px 12px; font-size:13px;
      border-bottom:1px solid #222; background:#141414; letter-spacing:0.2px;
    }
    .canvasWrap{ flex:1; min-height:0; }
    canvas{ width:100%; height:100%; display:block; }

    /* Empty state */
    .empty{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      color:#bbb; text-align:center; padding:20px;
      pointer-events:none;
    }
    .emptyBox{
      max-width:560px;
      border:1px dashed #333; border-radius:14px;
      padding:18px 16px; background:#0c0c0caa;
    }
    .emptyBox h2{ margin:0 0 8px 0; font-size:16px; color:#eee; }
    .emptyBox p{ margin:0; font-size:13px; line-height:1.5; color:#cfcfcf; }

    /* Modal preview */
    .modalBackdrop{
      position:fixed; inset:0; background:rgba(0,0,0,0.72);
      display:none; align-items:center; justify-content:center;
      padding:18px; box-sizing:border-box;
    }
    .modal{
      width:min(1100px, 95vw); height:min(92vh, 920px);
      background:#101010; border:1px solid #333; border-radius:14px;
      display:flex; flex-direction:column; min-height:0;
    }
    .modal header{
      padding:10px 12px; border-bottom:1px solid #222; background:#0f0f0f;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .badge{
      padding:6px 10px; border:1px solid #333; border-radius:999px; background:#1a1a1a;
      font-size:12px;
    }
    .modal .content{ flex:1; min-height:0; padding:10px; display:flex; align-items:center; justify-content:center; }
    .modal canvas{ background:#000; border-radius:12px; width:auto; height:auto; max-width:100%; max-height:100%; }
  </style>
</head>

<body>
<div class="app">
  <header>
    <div class="group">
      <button id="openBtn">Open images</button>
      <button id="demoBtn">Load demo</button>
      <input id="fileInput" type="file" accept="image/*" multiple hidden />
      <button id="pdfBtn" disabled>Download PDF</button>
    </div>

    <div class="group">
      <select id="orientSel" title="Orientation">
        <option value="portrait" selected>Portrait</option>
        <option value="landscape">Landscape</option>
      </select>

      <select id="dpiSel" title="Output DPI">
        <option value="150">150 dpi</option>
        <option value="200">200 dpi</option>
        <option value="300" selected>300 dpi</option>
        <option value="400">400 dpi</option>
        <option value="600">600 dpi</option>
      </select>
    </div>

    <div class="spacer"></div>

    <div class="meta" id="meta">
      <span id="status">No files loaded.</span>
      <span id="outInfo"></span>
    </div>

    <div class="keys">
      <span class="kbd">1-4</span> select • arrows move • <span class="kbd">+/-</span> zoom •
      <span class="kbd">Enter</span> preview • <span class="kbd">Esc</span> close • <span class="kbd">n/b</span> next/back
    </div>
  </header>

  <main>
    <section class="panel" style="position:relative;">
      <h3>Full image</h3>
      <div class="canvasWrap"><canvas id="fullCanvas"></canvas></div>
      <div class="empty" id="emptyOverlay">
        <div class="emptyBox">
          <h2>Pull Corners</h2>
          <p>
            Open images, then drag the four points to match the page corners.<br/>
            Press <b>Enter</b> to preview and download a flattened JPG, or export a PDF.
          </p>
        </div>
      </div>
    </section>

    <section class="panel">
      <h3>Zoom</h3>
      <div class="canvasWrap"><canvas id="zoomCanvas"></canvas></div>
    </section>
  </main>

  <div class="modalBackdrop" id="modalBackdrop" tabindex="-1">
    <div class="modal">
      <header>
        <span class="badge">Preview</span>
        <span class="badge">Enter = download JPG</span>
        <span class="badge">Esc = close</span>
        <span class="badge">Output: <b id="outName">—</b></span>
        <span class="badge" id="workBadge" style="display:none;">Working…</span>
      </header>
      <div class="content">
        <canvas id="previewCanvas"></canvas>
      </div>
    </div>
  </div>
</div>

<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
<script>
/* ---------- Demo (only loads on click) ---------- */
const DEMO = [
  { name: "S1.jpg", url: "figures/S1.jpg", kind: "demo" },
  { name: "S2.jpg", url: "figures/S2.jpg", kind: "demo" },
];

/* ---------- A4 inches ---------- */
const A4_IN = { w: 8.2677165, h: 11.6929134 };

let portraitMode = true;
let dpi = 300;
let OUT_W = 0, OUT_H = 0;

function updateOutputSize() {
  const wIn = portraitMode ? A4_IN.w : A4_IN.h;
  const hIn = portraitMode ? A4_IN.h : A4_IN.w;
  OUT_W = Math.round(wIn * dpi);
  OUT_H = Math.round(hIn * dpi);
  outInfoEl.textContent = ` • ${OUT_W}×${OUT_H}`;
}

/* ---------- UI ---------- */
const openBtn = document.getElementById("openBtn");
const demoBtn = document.getElementById("demoBtn");
const fileInput = document.getElementById("fileInput");
const pdfBtn = document.getElementById("pdfBtn");

const orientSel = document.getElementById("orientSel");
const dpiSel = document.getElementById("dpiSel");

const statusEl = document.getElementById("status");
const outInfoEl = document.getElementById("outInfo");
const emptyOverlay = document.getElementById("emptyOverlay");

const fullCanvas = document.getElementById("fullCanvas");
const zoomCanvas = document.getElementById("zoomCanvas");
const previewCanvas = document.getElementById("previewCanvas");

const modalBackdrop = document.getElementById("modalBackdrop");
const outNameEl = document.getElementById("outName");
const workBadge = document.getElementById("workBadge");

const fullCtx = fullCanvas.getContext("2d");
const zoomCtx = zoomCanvas.getContext("2d");

/* ---------- State ---------- */
let items = [];       // {name,url,kind,_blobUrl?}
let current = -1;

let img = new Image();
img.decoding = "async";
let imgLoaded = false;

let pts = null;       // [[x,y]...]
let active = 0;
let zoom = 6.0;
let dragging = false;

let fullScale=1.0, fullOffsetX=0, fullOffsetY=0, fullDrawW=0, fullDrawH=0;
const pageState = new Map(); // key -> {pts, zoom}

const PREVIEW_MAX_W = 1200;

function setStatus(t){ statusEl.textContent = t; }
function dpr(){ return Math.max(1, window.devicePixelRatio || 1); }

function resizeCanvasToCSS(canvas){
  const r = canvas.getBoundingClientRect();
  const s = dpr();
  const w = Math.max(1, Math.floor(r.width*s));
  const h = Math.max(1, Math.floor(r.height*s));
  if (canvas.width !== w || canvas.height !== h) { canvas.width=w; canvas.height=h; }
}

function pageKey(i){ return items[i]?.name ?? String(i); }

function defaultPointsForImage(){
  const w = img.naturalWidth, h = img.naturalHeight;
  return [
    [Math.round(w*0.1), Math.round(h*0.1)],
    [Math.round(w*0.9), Math.round(h*0.1)],
    [Math.round(w*0.9), Math.round(h*0.9)],
    [Math.round(w*0.1), Math.round(h*0.9)],
  ];
}

function savePageState(){
  if (!imgLoaded || current < 0) return;
  pageState.set(pageKey(current), { pts: pts.map(p=>[p[0],p[1]]), zoom });
}

function restorePageStateOrDefault(){
  const st = pageState.get(pageKey(current));
  if (st?.pts?.length === 4) { pts = st.pts.map(p=>[p[0],p[1]]); zoom = st.zoom ?? 6.0; }
  else { pts = defaultPointsForImage(); zoom = 6.0; }
  active = 0;
}

function clampPoint(i){
  const w = img.naturalWidth, h = img.naturalHeight;
  pts[i][0] = Math.max(0, Math.min(w-1, pts[i][0]));
  pts[i][1] = Math.max(0, Math.min(h-1, pts[i][1]));
}

function stepForZoom(){ return Math.max(1, Math.round(8/zoom)); }

function showLoadedUI(){
  emptyOverlay.style.display = "none";
  pdfBtn.disabled = false;
}

function clearToEmptyState(){
  items = [];
  current = -1;
  pageState.clear();
  imgLoaded = false;
  pdfBtn.disabled = true;
  emptyOverlay.style.display = "flex";
  setStatus("No files loaded.");
  fullCtx.clearRect(0,0,fullCanvas.width, fullCanvas.height);
  zoomCtx.clearRect(0,0,zoomCanvas.width, zoomCanvas.height);
}

/* ---------- Drawing ---------- */
function draw(){
  if (!imgLoaded) return;

  resizeCanvasToCSS(fullCanvas);
  resizeCanvasToCSS(zoomCanvas);

  const iw = img.naturalWidth, ih = img.naturalHeight;

  fullCtx.setTransform(1,0,0,1,0,0);
  fullCtx.clearRect(0,0,fullCanvas.width, fullCanvas.height);

  fullScale = Math.min(fullCanvas.width/iw, fullCanvas.height/ih);
  fullDrawW = Math.floor(iw*fullScale);
  fullDrawH = Math.floor(ih*fullScale);
  fullOffsetX = Math.floor((fullCanvas.width - fullDrawW)/2);
  fullOffsetY = Math.floor((fullCanvas.height - fullDrawH)/2);

  fullCtx.drawImage(img, 0,0,iw,ih, fullOffsetX, fullOffsetY, fullDrawW, fullDrawH);

  const p = pts.map(([x,y]) => [fullOffsetX + x*fullScale, fullOffsetY + y*fullScale]);

  fullCtx.strokeStyle = "#00ff6a";
  fullCtx.lineWidth = 2*dpr();
  fullCtx.beginPath();
  fullCtx.moveTo(p[0][0], p[0][1]);
  for (let i=1;i<4;i++) fullCtx.lineTo(p[i][0], p[i][1]);
  fullCtx.closePath();
  fullCtx.stroke();

  for (let i=0;i<4;i++){
    const [px,py] = p[i];
    fullCtx.fillStyle = (i===active) ? "#ff3b3b" : "#00ff6a";
    fullCtx.beginPath();
    fullCtx.arc(px, py, 7*dpr(), 0, Math.PI*2);
    fullCtx.fill();
    fullCtx.font = `${14*dpr()}px system-ui`;
    fullCtx.fillText(String(i+1), px + 10*dpr(), py + 5*dpr());
  }

  zoomCtx.setTransform(1,0,0,1,0,0);
  zoomCtx.clearRect(0,0,zoomCanvas.width, zoomCanvas.height);

  const [ax,ay] = pts[active];
  const base = 180;
  const half = Math.max(12, Math.floor(base/zoom));
  const x1 = Math.max(0, ax-half), y1 = Math.max(0, ay-half);
  const x2 = Math.min(iw, ax+half), y2 = Math.min(ih, ay+half);
  const cropW = x2-x1, cropH = y2-y1;

  const s2 = Math.min(zoomCanvas.width/cropW, zoomCanvas.height/cropH);
  const dw = Math.floor(cropW*s2), dh = Math.floor(cropH*s2);
  const zx = Math.floor((zoomCanvas.width-dw)/2);
  const zy = Math.floor((zoomCanvas.height-dh)/2);

  zoomCtx.drawImage(img, x1,y1,cropW,cropH, zx,zy,dw,dh);

  const cx = zx + (ax-x1)*s2;
  const cy = zy + (ay-y1)*s2;
  zoomCtx.strokeStyle = "#ff3b3b";
  zoomCtx.lineWidth = 2*dpr();
  zoomCtx.beginPath();
  zoomCtx.moveTo(cx-20*dpr(), cy); zoomCtx.lineTo(cx+20*dpr(), cy);
  zoomCtx.moveTo(cx, cy-20*dpr()); zoomCtx.lineTo(cx, cy+20*dpr());
  zoomCtx.stroke();

  setStatus(`${items[current].name} (${current+1}/${items.length})`);
}

/* ---------- Mouse interaction ---------- */
function fullCanvasToImage(e){
  const rect = fullCanvas.getBoundingClientRect();
  const s = dpr();
  const mx = (e.clientX - rect.left)*s;
  const my = (e.clientY - rect.top)*s;
  return [(mx - fullOffsetX)/fullScale, (my - fullOffsetY)/fullScale];
}
function dist2(a,b){ const dx=a[0]-b[0], dy=a[1]-b[1]; return dx*dx+dy*dy; }
function pickNearestPoint(x,y){
  const maxPx=35;
  let best=-1, bestD=1e18;
  for (let i=0;i<4;i++){
    const d=dist2([x,y], pts[i]);
    if (d<bestD){ bestD=d; best=i; }
  }
  return (Math.sqrt(bestD)<=maxPx) ? best : -1;
}

fullCanvas.addEventListener("mousedown",(e)=>{
  if(!imgLoaded) return;
  const [x,y]=fullCanvasToImage(e);
  const i=pickNearestPoint(x,y);
  if(i!==-1){ active=i; dragging=true; draw(); }
});
window.addEventListener("mouseup",()=> dragging=false);
fullCanvas.addEventListener("mousemove",(e)=>{
  if(!imgLoaded || !dragging) return;
  const [x,y]=fullCanvasToImage(e);
  pts[active][0]=Math.round(x);
  pts[active][1]=Math.round(y);
  clampPoint(active);
  savePageState();
  draw();
});

/* ---------- Warp math ---------- */
function solveLinearSystem(A,b){
  const n=b.length;
  const M=A.map((row,i)=>row.concat([b[i]]));
  for(let col=0; col<n; col++){
    let pivot=col;
    for(let r=col+1; r<n; r++){
      if(Math.abs(M[r][col])>Math.abs(M[pivot][col])) pivot=r;
    }
    if(Math.abs(M[pivot][col])<1e-12) throw new Error("Singular system");
    [M[col], M[pivot]]=[M[pivot], M[col]];
    const div=M[col][col];
    for(let c=col; c<=n; c++) M[col][c]/=div;
    for(let r=0; r<n; r++){
      if(r===col) continue;
      const f=M[r][col];
      for(let c=col; c<=n; c++) M[r][c]-=f*M[col][c];
    }
  }
  return M.map(row=>row[n]);
}
function computeHomography(srcPts,dstPts){
  const A=[], b=[];
  for(let i=0;i<4;i++){
    const [x,y]=srcPts[i];
    const [u,v]=dstPts[i];
    A.push([x,y,1, 0,0,0, -u*x,-u*y]); b.push(u);
    A.push([0,0,0, x,y,1, -v*x,-v*y]); b.push(v);
  }
  const x=solveLinearSystem(A,b);
  return [[x[0],x[1],x[2]],[x[3],x[4],x[5]],[x[6],x[7],1]];
}
function invert3x3(H){
  const a=H[0][0], b=H[0][1], c=H[0][2];
  const d=H[1][0], e=H[1][1], f=H[1][2];
  const g=H[2][0], h=H[2][1], i=H[2][2];
  const A=e*i-f*h, B=-(d*i-f*g), C=d*h-e*g;
  const D=-(b*i-c*h), E=a*i-c*g, F=-(a*h-b*g);
  const G=b*f-c*e, Hh=-(a*f-c*d), I=a*e-b*d;
  const det=a*A + b*B + c*C;
  if(Math.abs(det)<1e-12) throw new Error("Non-invertible homography");
  const inv=1/det;
  return [[A*inv,D*inv,G*inv],[B*inv,E*inv,Hh*inv],[C*inv,F*inv,I*inv]];
}
function applyHomography(H,x,y){
  const X=H[0][0]*x + H[0][1]*y + H[0][2];
  const Y=H[1][0]*x + H[1][1]*y + H[1][2];
  const W=H[2][0]*x + H[2][1]*y + H[2][2];
  return [X/W, Y/W];
}
function getPixelBilinear(src, sw, sh, x, y){
  if(x<0) x=0; if(y<0) y=0;
  if(x>sw-1) x=sw-1; if(y>sh-1) y=sh-1;
  const x0=Math.floor(x), y0=Math.floor(y);
  const x1=Math.min(sw-1, x0+1), y1=Math.min(sh-1, y0+1);
  const dx=x-x0, dy=y-y0;
  const i00=(y0*sw+x0)*4, i10=(y0*sw+x1)*4;
  const i01=(y1*sw+x0)*4, i11=(y1*sw+x1)*4;
  const out=[0,0,0,255];
  for(let c=0;c<3;c++){
    const p00=src[i00+c], p10=src[i10+c], p01=src[i01+c], p11=src[i11+c];
    const p0=p00*(1-dx)+p10*dx;
    const p1=p01*(1-dx)+p11*dx;
    out[c]=p0*(1-dy)+p1*dy;
  }
  return out;
}
function warpToCanvas(outputW, outputH, targetCanvas){
  const srcCanvas=document.createElement("canvas");
  srcCanvas.width=img.naturalWidth;
  srcCanvas.height=img.naturalHeight;
  const sctx=srcCanvas.getContext("2d",{willReadFrequently:true});
  sctx.drawImage(img,0,0);
  const sw=srcCanvas.width, sh=srcCanvas.height;
  const srcData=sctx.getImageData(0,0,sw,sh).data;

  const dstPts=[[0,0],[outputW-1,0],[outputW-1,outputH-1],[0,outputH-1]];
  const H = computeHomography(pts, dstPts);
  const Hinv = invert3x3(H);

  targetCanvas.width=outputW;
  targetCanvas.height=outputH;
  const tctx=targetCanvas.getContext("2d",{willReadFrequently:true});
  const outImg=tctx.createImageData(outputW, outputH);
  const out=outImg.data;

  let k=0;
  for(let y=0;y<outputH;y++){
    for(let x=0;x<outputW;x++,k+=4){
      const [sx,sy]=applyHomography(Hinv,x,y);
      const [r,g,b,a]=getPixelBilinear(srcData,sw,sh,sx,sy);
      out[k]=r; out[k+1]=g; out[k+2]=b; out[k+3]=a;
    }
  }
  tctx.putImageData(outImg,0,0);
}

/* ---------- Preview ---------- */
async function ensureImageDecoded(){
  if(typeof img.decode==="function"){ try{ await img.decode(); }catch(_){ } }
}
function fitA4InContainer(containerW, containerH){
  const ratio = OUT_H/OUT_W;
  let w = Math.min(containerW, PREVIEW_MAX_W);
  let h = w*ratio;
  if(h>containerH){ h=containerH; w=h/ratio; }
  return [Math.max(1,Math.floor(w)), Math.max(1,Math.floor(h))];
}
function openPreview(){
  if(!imgLoaded) return;
  savePageState();

  const base = items[current].name.replace(/\.[^.]+$/,"");
  outNameEl.textContent = `${base}_flat.jpg`;

  modalBackdrop.style.display="flex";
  workBadge.style.display="inline-flex";
  workBadge.textContent="Working…";

  setTimeout(async ()=>{
    try{
      await ensureImageDecoded();
      const content = previewCanvas.parentElement.getBoundingClientRect();
      const [pw,ph] = fitA4InContainer(content.width, content.height);
      warpToCanvas(pw, ph, previewCanvas);
      workBadge.style.display="none";
      modalBackdrop.focus();
    }catch(e){
      workBadge.textContent="Error";
      setStatus("Preview failed: "+e.message);
    }
  },10);
}
function closePreview(){ modalBackdrop.style.display="none"; }

function downloadCurrentFlatJpg(){
  const base = items[current].name.replace(/\.[^.]+$/,"");
  const outName = `${base}_flat.jpg`;

  workBadge.style.display="inline-flex";
  workBadge.textContent="Rendering…";

  setTimeout(async ()=>{
    try{
      await ensureImageDecoded();
      const off=document.createElement("canvas");
      warpToCanvas(OUT_W, OUT_H, off);
      off.toBlob((blob)=>{
        const a=document.createElement("a");
        a.href=URL.createObjectURL(blob);
        a.download=outName;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
        workBadge.style.display="none";
        closePreview();
      }, "image/jpeg", 0.95);
    }catch(e){
      workBadge.textContent="Error";
      setStatus("Download failed: "+e.message);
    }
  },10);
}

/* ---------- Load / navigation ---------- */
async function loadImageFromCurrent(){
  imgLoaded=false;
  setStatus("Loading image…");
  await new Promise((resolve)=>{
    img.onload=resolve; img.onerror=resolve;
    img.src = items[current].url;
  });
  if(!img.naturalWidth){ setStatus("Failed to load image."); return false; }
  imgLoaded=true;
  showLoadedUI();
  return true;
}

async function gotoPage(i){
  if(i<0 || i>=items.length) return;
  if(current>=0) savePageState();
  current=i;
  const ok=await loadImageFromCurrent();
  if(!ok) return;
  restorePageStateOrDefault();
  draw();
}

async function loadItems(newItems, {hideDemoButton=false}={}){
  // revoke old blob URLs
  for(const it of items){ if(it._blobUrl) URL.revokeObjectURL(it.url); }
  pageState.clear();
  items = newItems;
  current = -1;

  if (hideDemoButton) demoBtn.style.display = "none";

  await gotoPage(0);
}

/* ---------- PDF export ---------- */
async function downloadPdfAll(){
  if(!items.length) return;
  setStatus("Building PDF…");
  pdfBtn.disabled = true;

  try{
    savePageState();
    const { PDFDocument } = PDFLib;
    const pdf = await PDFDocument.create();
    const off = document.createElement("canvas");

    for(let i=0;i<items.length;i++){
      await gotoPage(i);
      await ensureImageDecoded();
      warpToCanvas(OUT_W, OUT_H, off);

      const jpgBytes = await new Promise((resolve)=>{
        off.toBlob(async (b)=> resolve(await b.arrayBuffer()), "image/jpeg", 0.95);
      });

      const jpg = await pdf.embedJpg(jpgBytes);
      const page = pdf.addPage([OUT_W, OUT_H]);
      page.drawImage(jpg, {x:0,y:0,width:OUT_W,height:OUT_H});
      setStatus(`Building PDF… ${i+1}/${items.length}`);
    }

    const pdfBytes = await pdf.save();
    const blob = new Blob([pdfBytes], {type:"application/pdf"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download="report.pdf";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(a.href), 1000);

    setStatus("PDF ready.");
  }catch(e){
    setStatus("PDF failed: "+e.message);
  }finally{
    pdfBtn.disabled = false;
  }
}

/* ---------- Controls ---------- */
openBtn.onclick = ()=> fileInput.click();

fileInput.onchange = async ()=>{
  if(!fileInput.files?.length) return;

  const fs = Array.from(fileInput.files).sort((a,b)=>
    a.name.localeCompare(b.name, undefined, {numeric:true, sensitivity:"base"})
  );
  const userItems = fs.map(f=>({name:f.name, url:URL.createObjectURL(f), _blobUrl:true, kind:"user"}));

  // Requirement: if someone opens files, remove open demo button
  await loadItems(userItems, {hideDemoButton:true});
};

demoBtn.onclick = async ()=>{
  await loadItems(DEMO.slice(), {hideDemoButton:false});
};

pdfBtn.onclick = downloadPdfAll;

orientSel.onchange = ()=>{
  portraitMode = orientSel.value === "portrait";
  updateOutputSize();
};

dpiSel.onchange = ()=>{
  dpi = parseInt(dpiSel.value, 10);
  updateOutputSize();
};

modalBackdrop.addEventListener("click",(e)=>{
  if(e.target===modalBackdrop) closePreview();
});

window.addEventListener("resize", ()=> { if(imgLoaded) draw(); });

/* ---------- Keyboard ---------- */
window.addEventListener("keydown",(e)=>{
  if(!imgLoaded) return;

  const modalOpen = modalBackdrop.style.display === "flex";
  if(modalOpen){
    if(e.key==="Escape"){ closePreview(); e.preventDefault(); return; }
    if(e.key==="Enter"){ downloadCurrentFlatJpg(); e.preventDefault(); return; }
    return;
  }

  if(["1","2","3","4"].includes(e.key)){ active=Number(e.key)-1; draw(); e.preventDefault(); return; }
  if(e.key==="+" || e.key==="="){ zoom=Math.min(50, zoom*1.25); savePageState(); draw(); e.preventDefault(); return; }
  if(e.key==="-" || e.key==="_"){ zoom=Math.max(1.5, zoom/1.25); savePageState(); draw(); e.preventDefault(); return; }

  if(e.key==="Enter"){ openPreview(); e.preventDefault(); return; }
  if(e.key==="n"){ if(current<items.length-1) gotoPage(current+1); e.preventDefault(); return; }
  if(e.key==="b"){ if(current>0) gotoPage(current-1); e.preventDefault(); return; }

  const step = stepForZoom();
  if(e.key==="ArrowLeft"){ pts[active][0]-=step; clampPoint(active); savePageState(); draw(); e.preventDefault(); return; }
  if(e.key==="ArrowRight"){ pts[active][0]+=step; clampPoint(active); savePageState(); draw(); e.preventDefault(); return; }
  if(e.key==="ArrowUp"){ pts[active][1]-=step; clampPoint(active); savePageState(); draw(); e.preventDefault(); return; }
  if(e.key==="ArrowDown"){ pts[active][1]+=step; clampPoint(active); savePageState(); draw(); e.preventDefault(); return; }
});

/* ---------- Start empty ---------- */
updateOutputSize();
clearToEmptyState();
</script>
</body>
</html>
